# -*- coding: utf-8 -*-

"""
Define a sql domain with 4 directives::

    ..  sql:table::
    ..  sql:query::
    ..  sql:view::
    ..  sql:constraints::

These objects are added to the index and can be referenced inline like :sql:table:`MyTable`.

See the documentation in this package for more information.

"""


__all__ = [
    'sql_custom_domain',
    'app_add_node_addSQLTableSignatureNode',
    'app_add_node_addSQLTableColumnNode'
]



import re

from docutils import nodes
from sphinx import addnodes

from sphinx.util.docfields import GroupedField
from sphinxcontrib_domaintools import custom_domain


#-----------------------------------------------------------------------

class SQLTableSignatureNode(nodes.Part, nodes.Inline, nodes.TextElement):
    """Node for a general parameter list."""
    child_text_separator = ', '

def argumentlist_visit(self, node):
    self.visit_desc_parameterlist(node)

def argumentlist_depart(self, node):
    self.depart_desc_parameterlist(node)

def html_argumentlist_visit(self, node):
    self.visit_desc_parameterlist(node)
    if len(node.children) > 3:
        self.body.append('<span class="long-argument-list">')
    else:
        self.body.append('<span class="argument-list">')

def html_argumentlist_depart(self, node):
    self.body.append('</span>')
    self.depart_desc_parameterlist(node)


def app_add_node_addSQLTableSignatureNode(app):
    app.add_node(
        node = SQLTableSignatureNode,
        html = (html_argumentlist_visit, html_argumentlist_depart),
        latex = (argumentlist_visit, argumentlist_depart),
    )




#-----------------------------------------------------------------------

class SQLTableColumnNode(nodes.Part, nodes.Inline, nodes.TextElement):
    """Node for an argument wrapper"""

def argument_visit(self, node):
    pass

def argument_depart(self, node):
    pass

def html_argument_visit(self, node):
    self.body.append('<span class="arg">')

def html_argument_depart(self, node):
    self.body.append("</span>")

def app_add_node_addSQLTableColumnNode(app):
    app.add_node(
        node = SQLTableColumnNode,
        html = (html_argument_visit, html_argument_depart),
        latex = (argument_visit, argument_depart),
    )



sql_table_signature_re = re.compile(r'(\w+)\s*\(([^)]*)\)')

sql_column_re = re.compile(
        r'(?P<key>#)?\s*(?P<name>\w+)\s*(:\s*(?P<type>\w+))?\s*(?P<optional>\?)?\s*(?P<reference>>+)?\s*')





def _get_column_node(m):
    if m.group('name'):
        node = addnodes.desc_parameter()

        if m.group('key'):
            node += nodes.Text("#", "#")

        key = nodes.strong(m.group('name'), m.group('name'))
        key['classes'].append('arg-key')
        node += key

        if m.group('type'):
            node += nodes.Text(" : ", " : ")
            value = nodes.inline(m.group('type'), m.group('type'))
            value['classes'].append('arg-value')  # FIXME: should vbe arg type probably
            node += value

        if m.group('optional'):
            node += nodes.Text("? ", "?")  # FIXME: find a better type

        if m.group('reference'):
            value = nodes.inline(m.group('reference'), m.group('reference'))
            value['classes'].append('arg-value')  # FIXME: should vbe arg type probably
            node += value

        return node

    else:
        return addnodes.desc_parameter(m.group(0), m.group(0))


#-----------------------------------------------------------------------

def parse_signature_with_kind(kind):

    def parse_signature(env, sig, signode):
        m = sql_table_signature_re.match(sig)
        if not m:
            signode += addnodes.desc_name(sig, sig)
            return sig
        name, args = m.groups()
        # TODO: This should be improved with a more appropriate node.
        # Look for instance at the code generated by ..  py:class:: babar
        signode += addnodes.desc_type(kind+' ',kind+' ')

        # Add the name of the class
        signode += addnodes.desc_name(name, name)
        plist = SQLTableSignatureNode()
        for m in sql_column_re.finditer(args):
            x = SQLTableColumnNode()
            x += _get_column_node(m)
            plist += x

        signode += plist
        return name

    return parse_signature


#-----------------------------------------------------------------------------


sql_custom_domain = \
    custom_domain('SQLDomain',
        name  = 'sql',
        label = "SQL",

        elements = dict(
            table = dict(
                role = 'table',
                objtype = 'table',
                objname       = "SQL Table",
                indextemplate = "pair: %s; SQL table",
                parse         = parse_signature_with_kind('table'),
                fields        = [
                    GroupedField('column',
                        label = "Columns",
                        names = [ 'column', 'col' ]),
                    GroupedField('constraint',
                        label = 'Constraints',
                        names = [ 'constraint', 'con' ]),
                    GroupedField('example',
                        label = 'Examples',
                        names = [ 'example', 'ex' ]),
                ]
            ),

            query = dict(
                role = 'query',
                objtype = 'query',
                objname       = "SQL Query",
                indextemplate = "pair: %s; SQL query",
                parse         = parse_signature_with_kind('query'),
                fields        = [
                    GroupedField('column',
                        label = "Columns",
                        names = [ 'column', 'col' ]),
                    GroupedField('constraint',
                        label = 'Constraints',
                        names = [ 'constraint', 'con' ]),
                    GroupedField('example',
                        label = 'Examples',
                        names = [ 'example', 'ex' ]),
                ]
            ),

            view = dict(
                role = 'view',
                objtype = 'view',
                objname       = "SQL View",
                indextemplate = "pair: %s; SQL view",
                parse         = parse_signature_with_kind('view'),
                fields        = [
                    GroupedField('column',
                        label = "Columns",
                        names = [ 'column', 'col' ]),
                    GroupedField('constraint',
                        label = 'Constraints',
                        names = [ 'constraint', 'con' ]),
                    GroupedField('example',
                        label = 'Examples',
                        names = [ 'example', 'ex' ]),
                ]
            ),

            constraint = dict(
                role = 'constraint',
                objtype = 'constraint',
                objname       = "Constraint",
                indextemplate = "pair: %s; constraint",
                parse         = parse_signature_with_kind('view'),  # TODO check what to do
            ),

        )
    )

