#!/usr/bin/env bash
"""
Parse error message output by sphinx.
"""
import re

import problems


def shortenedMessage(message):
    """
    Check if the message should be shortened or is parametrized by some value(s).
    If this is the case return the shortened form as well as a detail message.
    Otherwise return the message and the empty string since no details is needed.
    :param message: the message to shorten
    :return: (str,str)
    """
    patterns = [

        ('Block quote ends without a blank line; unexpected unindent.',
            'Block quote ends without a blank line'),
        ('Bullet list ends without a blank line; unexpected unindent.',
            'Bullet list ends without a blank line; unexpected unindent'),


        ('Definition list ends without a blank line; unexpected unindent.',
            'Definition list ends without a blank line'),
        ('document isn\'t included in any toctree',
            'Document not in toctree'),
        ('download file not readable: (?P<file>.*)',
            'Download file not readable'),
        ('duplicate label .*',
            'Duplicate label'),
        ('Duplicate ID:.*',
            'Duplicate ID'),
        ('Duplicate explicit target name:.*',
            'Duplicate explicit target name'),

        ('Error in .*glossary.* directive:',
            'Error in "glossary" directive'),
        ('Error in .*replace.* directive: may contain a single paragraph only.',
            'Error in "replace" directive'),
        ('Error in .*csv-table.* directive:',
            'Error in "csv-table" directive'),
        ('Error with CSV data in .*csv-table.* directive:',
            'Error with CSV data'),
        ('Error in .*todo.* directive:',
            'Error in "todo" directive'),
        ('Explicit markup ends without a blank line; unexpected unindent.',
            'Explicit markup ends without a blank line; unexpected unindent'),

        ('Field list ends without a blank line; unexpected unindent.',
            'Field list ends without a blank line; unexpected unindent'),

        ('glossary term must be preceded by empty line',
            'Empty line before term'),
        ('glossary terms must not be separated by empty lines',
            'No empty line between terms'),
        ('glossary seems to be misformatted, check indentation',
            'Glossary misformatted'),

        ('image file not readable: .*',
            'Image file not readable'),
        ('Include file (?P<file>.*) not found or reading it failed',
            'Include file not found'),
        ('Invalid section title or transition marker.',
            'Invalid section title or transition marker'),
        ('Inline interpreted text or phrase reference start-string without end-string.',
            'Inline interpreted text or phrase reference start-string without end-string'),
        ('Inline substitution_reference start-string without end-string.',
            'Missing substitution end-string'),
        ('Inline emphasis start-string without end-string.',
            'Inline emphasis start-string without end-string'),
        ('Inline literal start-string without end-string.',
            'Inline literal start-string without end-string'),

        ('more than one target found for .* cross-reference.*',
            'Ambiguous target'),

        ('Problems with .*csv-table.* directive path:.*',
            'Problems with "csv-table" directive'),
        ('Problem with .*include.* directive:.*',
            'Problem with "include" directive'),

        ('reference not found: .*',   # warning generated by missingrefs
            'Reference not found'),
        ('.* reference target not found: .*',
            'Reference not found'),

        ('Substitution definition .* empty or invalid.',
            'Invalid substitution definition'),

        ('Title underline too short.',
            'Title underline too short'),
        ('Title overline & underline mismatch.',
            'Title overline and underline mismatch'),
        ('Title level inconsistent:',
            'Title level inconsistent'),
        ('toctree contains reference to nonexisting document (?P<document>.*)',
            'Non existing document'),
        ('toctree contains reference to document .* that doesn\'t have a title',
            'Untitled document in toctree'),



        ('Unknown directive type .*',
            'Unknown directive type'),
        ('Undefined substitution referenced: .*',
            'Undefined substitution reference'),
        ('.*undecodable source characters, replacing with.*',
            'Undecodable characters'),
        ('Unexpected indentation.',
            'Unexpected indentation'),
        ('Unexpected section title or transition.',
            'Unexpected title or transition'),
    ]
    for (pattern,replacement) in patterns:
        m = re.match(pattern, message)
        if m:
            return (replacement, message)
    return (message+' ...', '')



def parseErrorFile(sphinxRootDirectory, file, problemManager):
    """
    Parse the output of sphinx errors and add the problems to the problems.MANAGER.
    Unrecognized lines (e.g. lines at the begining of the file that are not
    WARNING,ERROR,SEVERER) produce UnknownProblem.
    :param file: an error file generated by sphinx
    :return: list[problems.Problem] the list of problem created.
    """
    problem_pattern = \
        "^((?P<file>.*):(?P<line>\d*): *)?(?P<type>WARNING|ERROR|SEVERE): *(?P<message>.*)"

    lines = [line.rstrip('\n') for line in open(file)]
    current_problem = None   # could be set to an UnknownProblem
    problem_list = []
    for line in lines:
        m=re.match(problem_pattern, line)
        if m:
            (short_message, detail) = shortenedMessage(m.group('message'))
            if m.group('line') == '' or m.group('line') is None:
                line = None
            else:
                line = int(m.group('line'))
            current_problem = problems.Problem(
                    sphinxRootDirectory=sphinxRootDirectory,
                    source=m.group('file'),
                    type=m.group('type'),
                    line=line,
                    message=short_message,
                    content=detail
                )
            problemManager.addProblem(current_problem)
            problem_list.append(current_problem)
        else:
            if current_problem is None:
                # a unrecognized line at the beginning of the file
                current_problem = problems.UnknownProblem(
                    sphinxRootDirectory=sphinxRootDirectory,
                    content=line)
                problemManager.addProblem(current_problem)
                problem_list.append(current_problem)
            else:
                # content line for last problem
                current_problem.appendToContent(line)



# ^(?P<file>:\d+\:WARNING:)/media/jmfavre/Windows/DEV/m2cci/m2cci-pi-groups/m2cci-pi-GPI01/Donnees/ModeleLogique/Index.rst:29: WARNING: Title underline too short.